"""
Quick Sort
---------------

Quick Sort (быстрая сортировка) - самый эффективный алгоритм сортировки из представленных здесь.

Состоит из 3-ёх этапов:
	1. Выбирается один опорный элемент, стержень (pivot)
	2. Все элементы меньше опорного перемешаются слева от него, остальные — направо. Это называется операцией разбиения.
	3. Рекурсивно повторяются 2 предыдущих шага к каждому новому списку, где новые опорные элементы будут меньше и больше оригинального соответственно.

Важнейшая часть алгоритмма - разбиение (partioning). Сначала `опора` берётся, список подделён на 2 части: одна часть содержит все элементы меньше `основы`, а другая часть, содержит элементы больше `основы`. Одиннаковые элементы могут быть в разных частях.

[2, 0, 7, 4, 3]

[2, 0] (3) [7, 4]
[(0) [2]] (3) [(4) [7]]

Преимущества и недостатки:
	+ Не требует дополнительной памяти.
	+ Рандомизированная версия алгоритма является наиболее эффективной.

	- Выбор основы сильно влияет на эффективность алгоритма
"""
from random import randint


def quick_sort(arr, start, end):
	if start < end:
		# Рандомно выбираем опору
		pivot = randint(start, end)
		# Меняем опору с последним элементом
		arr[end], arr[pivot] = arr[pivot], arr[end] 
		# Разибиваем список
		split = partion(arr, start, end)

		# Рекурсивно сортируем обе части
		quick_sort(arr, start, split - 1)
		quick_sort(arr, split + 1, end)


def partion(arr, start, end):
	pivot_index = start - 1

	for index in range(start, end):
		if arr[index] < arr[end]:
			pivot_index += 1
			# Меняем. Медленно с левого и правого бока будет происходить сортировка
			arr[pivot_index], arr[index] = arr[index], arr[pivot_index]
	
	# Меняем последний элемент
	arr[pivot_index + 1], arr[end] = arr[end], arr[pivot_index + 1]
		
	return pivot_index + 1


nums = [7, 2, 5, 1, 29, 6, 4, 19, 11]
quick_sort(nums, 0, len(nums)-1)
print(nums)