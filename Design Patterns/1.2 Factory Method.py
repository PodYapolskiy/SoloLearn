"""
Factory method
-------------------

Фабричный метод — это порождающий паттерн проектирования, который определяет общий интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов.

Подклассы могут изменять класс создаваемых объектов.

Чтобы эта система заработала, все возвращаемые объекты должны иметь общий интерфейс. Подклассы смогут производить объекты различных классов, следующих одному и тому же интерфейсу.

Все объекты-продукты должны иметь общий интерфейс.

Ориентируясь на даннную картинку:
https://refactoring.guru/images/patterns/diagrams/factory-method/structure-indexed.png?id=4c603207859ca1f939b1

1. Продукт определяет общий интерфейс объектов, которые может произвести создатель и его подклассы.
2. Конкретные продукты содержат код различных продуктов. Продукты будут отличаться реализацией, но интерфейс у них будет общий.
3. Создатель объявляет фабричный метод, который должен возвращать новые объекты продуктов. Важно, чтобы тип результата совпадал с общим интерфейсом продуктов.
4. Конкретные создатели по-своему реализуют фабричный метод, производя те или иные конкретные продукты.

Фабричный метод не обязан всё время создавать новые объекты. Его можно переписать так, чтобы возвращать существующие объекты из какого-то хранилища или кэша.


Применяемость:
	- Заранее неизвестны типы и зависимости объектов.
	- Когда вы хотите дать возможность пользователям расширять части вашего фреймворка или библиотеки.
	- Когда вы хотите экономить системные ресурсы, повторно используя уже созданные объекты, вместо порождения новых.


Шаги реализации:
	1. Приведите все создаваемые продукты к общему интерфейсу.
	2. В классе, который производит продукты, создайте пустой фабричный метод. В качестве возвращаемого типа укажите общий интерфейс продукта.
	3. Затем пройдитесь по коду класса и найдите все участки, создающие продукты. Поочерёдно замените эти участки вызовами фабричного метода, перенося в него код создания различных продуктов.
	4. Для каждого типа продуктов заведите подкласс и переопределите в нём фабричный метод. Переместите туда код создания соответствующего продукта из суперкласса.
	5. Если создаваемых продуктов слишком много для существующих подклассов создателя, вы можете подумать о введении параметров в фабричный метод, которые позволят возвращать различные продукты в пределах одного подкласса.
	6. Если после всех перемещений фабричный метод стал пустым, можете сделать его абстрактным. Если в нём что-то осталось — не беда, это будет его реализацией по умолчанию.


Преимущества и недостатки:
	+ Избавляет класс от привязки к конкретным классам продуктов.
	+ Выделяет код производства продуктов в одно место, упрощая поддержку кода.
	+ Упрощает добавление новых продуктов в программу.
	+ Реализует принцип открытости/закрытости.

	- Может привести к созданию больших параллельных иерархий классов, так как для каждого класса продукта надо создать свой подкласс создателя.



https://refactoring.guru/ru/design-patterns/factory-method
https://refactoring.guru/ru/design-patterns/factory-method/python/example
"""
from abc import ABC, abstractmethod


class Creator(ABC):
	"""
	Класс Создатель объявляет фабричный метод, который должен возвращать объект
	класса Продукт. Подклассы Создателя обычно предоставляют реализацию этого
	метода.
	"""

	@abstractmethod
	def factory_method(self):
		"""
		Обратите внимание, что Создатель может также обеспечить реализацию
		фабричного метода по умолчанию.
		"""
		pass

	def some_operation(self) -> str:
		"""
		Также заметьте, что, несмотря на название, основная обязанность
		Создателя не заключается в создании продуктов. Обычно он содержит
		некоторую базовую бизнес-логику, которая основана на объектах Продуктов,
		возвращаемых фабричным методом. Подклассы могут косвенно изменять эту
		бизнес-логику, переопределяя фабричный метод и возвращая из него другой
		тип продукта.
		"""

		# Вызываем фабричный метод, чтобы получить объект-продукт.
		product = self.factory_method()

		# Далее, работаем с этим продуктом.
		result = f"Creator: The same creator's code has just worked with {product.operation()}"

		return result


# Конкретные Создатели переопределяют фабричный метод для того, чтобы изменить тип результирующего продукта.


class ConcreteCreator1(Creator):
	"""
	Обратите внимание, что сигнатура метода по-прежнему использует тип
	абстрактного продукта, хотя фактически из метода возвращается конкретный
	продукт. Таким образом, Создатель может оставаться независимым от конкретных
	классов продуктов.
	"""
	def factory_method(self) -> "Product":
		return ConcreteProduct1()


class ConcreteCreator2(Creator):
	def factory_method(self) -> "Product":
		return ConcreteProduct2()


class Product(ABC):
	"""
	Интерфейс Продукта объявляет операции, которые должны выполнять все
	конкретные продукты.
	"""

	@abstractmethod
	def operation(self) -> str:
		pass


# Конкретные Продукты предоставляют различные реализации интерфейса Продукта.


class ConcreteProduct1(Product):
	def operation(self) -> str:
		return "{Result of the ConcreteProduct1}"


class ConcreteProduct2(Product):
	def operation(self) -> str:
		return "{Result of the ConcreteProduct2}"


def client_code(creator: Creator) -> None:
	"""
	Клиентский код работает с экземпляром конкретного создателя, хотя и через
	его базовый интерфейс. Пока клиент продолжает работать с создателем через
	базовый интерфейс, вы можете передать ему любой подкласс создателя.
	"""

	print(f"Client: I'm not aware of the creator's class, but it still works.\n" + \
		  f"{creator.some_operation()}", end="")


if __name__ == "__main__":
	print("App: Launched with the ConcreteCreator1.")
	client_code(ConcreteCreator1())
	print("\n")

	print("App: Launched with the ConcreteCreator2.")
	client_code(ConcreteCreator2())
