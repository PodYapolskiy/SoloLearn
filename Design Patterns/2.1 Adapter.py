"""
Adapter
------------

Адаптер - структурный паттерн проектирования, который позволяет объектам с несовместимыми интерфейсами работать вместе. Это объект-переводчик, который трансформирует интерфейс или данные одного объекта в такой вид, чтобы он стал понятен другому объекту. При этом адаптер оборачивает один из объектов, так что другой объект даже не знает о наличии первого.

Пирнцип работы:
    1. Адаптер имеет интерфейс, который совместим с одним из объектов.
    2. Поэтому этот объект может свободно вызывать методы адаптера.
    3. Адаптер получает эти вызовы и перенаправляет их второму объекту, но уже в том формате и последовательности, которые понятны второму объекту.


Адаптер объектов:
    Эта реализация использует агрегацию: объект адаптера «оборачивает», то есть содержит ссылку на служебный объект.
    https://refactoring.guru/images/patterns/diagrams/adapter/structure-object-adapter-indexed-2x.png

    1) Клиент — это класс, который содержит существующую бизнес-логику программы.

    2) Клиентский интерфейс описывает протокол, через который клиент может работать с другими классами.

    3) Сервис — это какой-то полезный класс, обычно сторонний. Клиент не может использовать этот класс напрямую, так как сервис имеет непонятный ему интерфейс.

    4) Адаптер — это класс, который может одновременно работать и с клиентом, и с сервисом. Он реализует клиентский интерфейс и содержит ссылку на объект сервиса. Адаптер получает вызовы от клиента через методы клиентского интерфейса, а затем переводит их в вызовы методов обёрнутого объекта в правильном формате.

    5) Работая с адаптером через интерфейс, клиент не привязывается к конкретному классу адаптера. Благодаря этому, вы можете добавлять в программу новые виды адаптеров, независимо от клиентского кода. Это может пригодиться, если интерфейс сервиса вдруг изменится, например, после выхода новой версии сторонней библиотеки.


Адаптер классов:
    Эта реализация базируется на наследовании: адаптер наследует оба интерфейса одновременно.
    https://refactoring.guru/images/patterns/diagrams/adapter/structure-class-adapter-indexed-2x.png

    1) Адаптер классов не нуждается во вложенном объекте, так как он может одновременно наследовать и часть существующего класса, и часть сервиса.


Применимость:
    - Когда вы хотите использовать сторонний класс, но его интерфейс не соответствует остальному коду приложения.
    -  Когда вам нужно использовать несколько существующих подклассов, но в них не хватает какой-то общей функциональности, причём расширить суперкласс вы не можете.


Шаги реализации:
    1. Убедитесь, что у вас есть два класса с несовместимыми интерфейсами.
    2. Опишите клиентский интерфейс, через который классы приложения смогли бы использовать класс сервиса.
    3. Создайте класс адаптера, реализовав этот интерфейс.
    4. Поместите в адаптер поле, которое будет хранить ссылку на объект сервиса.
    5. Реализуйте все методы клиентского интерфейса в адаптере. Адаптер должен делегировать основную работу сервису.
    6. Приложение должно использовать адаптер только через клиентский интерфейс.


Преимущества и недостатки:
    + Отделяет и скрывает от клиента подробности преобразования различных интерфейсов.

    - Усложняет код программы из-за введения дополнительных классов.


https://refactoring.guru/ru/design-patterns/adapter
"""
class Target:
    """
    Целевой класс объявляет интерфейс, с которым может работать клиентский код.
    """

    def request(self) -> str:
        return "Target: The default target's behavior."


class Adaptee:
    """
    Адаптируемый класс содержит некоторое полезное поведение, но его интерфейс
    несовместим с существующим клиентским кодом. Адаптируемый класс нуждается в
    некоторой доработке, прежде чем клиентский код сможет его использовать.
    """

    def specific_request(self) -> str:
        return ".eetpadA eht fo roivaheb laicepS"


class Adapter(Target, Adaptee):
    """
    Адаптер делает интерфейс Адаптируемого класса совместимым с целевым
    интерфейсом благодаря множественному наследованию.
    """

    def request(self) -> str:
        return f"Adapter: (TRANSLATED) {self.specific_request()[::-1]}"


def client_code(target: "Target") -> None:
    """
    Клиентский код поддерживает все классы, использующие интерфейс Target.
    """

    print(target.request(), end="")


if __name__ == "__main__":
    print("Client: I can work just fine with the Target objects:")
    target = Target()
    client_code(target)
    print("\n")

    adaptee = Adaptee()
    print("Client: The Adaptee class has a weird interface. "
          "See, I don't understand it:")
    print(f"Adaptee: {adaptee.specific_request()}", end="\n\n")

    print("Client: But I can work with it via the Adapter:")
    adapter = Adapter()
    client_code(adapter)
